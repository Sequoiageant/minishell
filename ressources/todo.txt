A COMMENCER

- Creer une fonction d'exit
- Creer une fonction display_prompt() ?
- Signal CTRL + \
- Variable $? et retour des fonctions
- Coder la partie 'recherche de l'executable dans le PATH'
	--> Faire un split sur ':' des val de la key "PATH" de t_list env
	--> boucler sur le tableau des path et ouvrir chaque dir avec opendir()
	--> Récupérer l'ensemble des fichiers contenus dans chaque directory du PATH avec readdir() (ceux-ci sont stockés dans une structure dirent.d_name)
	--> Comparer les noms des binaires trouvés avec la commande rentrée dans notre shell
	--> Si cmd/binaire_name matchent, alors fork()
- Faire une fonction de conversion de la t_list env en char **
- Coder la gestion des redirections > >> <
- Coder les redirections de pipeline (et le fait que les commandes d'un pipeline s'executent simmultanément)
- Coder les built ins


CODE

- pid globale: voir s'il faut un tableau/liste de pid


NORME

- proteger les mallocs
- read du buffer: pour l'instant limité à 1000 char -> voir si meilleur methode --> utiliser gnl ? Une boucle sur read ?
- changer les headers "grim" ?
- pid globale = OK norme ?
- Réarranger le Makefile afin d'enlever la wildcard


PARSING

- $ENV:
    gérer les cas "non basiques" de substitution ?
    -- forme basique: $VAR
    -- forme $!VAR  (parameter indirection)
    -- forme ${VAR}  (pour bien séparer la VAR de ce qu'il y a derrière)
    -- formes du type ${VAR:word}

- > FILE:
    pour l'instant, après > ou >>, le parser lit tout ce qu'il trouve jusqu'à '/0' ou ';' ou '|', et le stock dans le filename (en elevant les espaces au début et à la fin si necessaire)
    ---> ne correspond pas toujours au comportement de bash, dans des cas comme:
        echo test > file divers [bash ignore le mot "divers" et créé le fichier "file" vs "file divers" pour nous]

- parsing: à la fin d'un pipe, verifier que les flags ' et " soient desactivés --> si les quote n'est pas fermé, c'est du MULTILINE -> pas à gérer donc on fait comme on veut
