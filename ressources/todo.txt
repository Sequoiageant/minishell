A COMMENCER

- Creer une fonction display_prompt() ?
- Exit status de minishell (Bash itself returns the exit status of the last command executed, unless a syntax error occurs, in which case it exits with a non-zero value)

BUILT INS

- built in cd: 
    recherche dans CDVAR & 
    gérer ou non le cas "invalid option" (exit code = 2) ?
- built in echo: gerer ou non l'éventualité d'un problème de "write"
- voir si on ajoute une condition pour les built ins qui exit avec 2

AUTRE

- problème: quand on appelle un executable qui est dans le current folder, si on fait cmd: ./nom_executable c'est sensé marcher mais si on fait cmd: nom_executable c'est pas sensé marcher. or nous ca marche aussi dans le 2em cas
    -> lié à cmdpath ?
- pid globale: voir s'il faut un tableau/liste de pid
- ctrl c marche sur une commande du pipe, autre que la dernière ? -> a priori le cas ne risque pas de se présenter
- utiliser le char **env argument du main plutot que __environ pour récupérer l'environnement ? 
- redirs: sur les execed cmds, voir s'il faut "restaurer stdout / stdin" -> a priori on en a plus besoin, car si l'execve retourne une erreur: dans ce cas on affiche le message d'erreur sur STDERR
- dans le cas d'un pipe, est ce qu'il faut 'wait' autres les forked process (car sinon deviennent "zombie" et consomment des ressources) ?

BONUS (?)

- gérer les "variable assigmenent" ? ex: foo=bar
- $ENV:
    gérer les cas "non basiques" de substitution ?
    -- forme basique: $VAR
    -- forme $!VAR  (parameter indirection)
    -- forme ${VAR}  (pour bien séparer la VAR de ce qu'il y a derrière)
    -- formes du type ${VAR:word}
- built in export: gerer le += = BONUS

NORME

- proteger les mallocs, pipe, fork, dup ... -> voir quand ca vaut le coup :)
- read du buffer: pour l'instant limité à 1000 char -> voir si meilleur methode --> utiliser gnl ? Une boucle sur read ? ==> gnl retenu
- changer les headers "grim" ?
- pid globale = OK norme ?
- norminette partout
- mettre des "static"

PARSING

- Gérer les erreurs de synthaxe ?

- > FILE:
    pour l'instant, après > ou >>, le parser lit tout ce qu'il trouve jusqu'à '/0' ou ';' ou '|', et le stock dans le filename (en elevant les espaces au début et à la fin si necessaire)
    ---> ne correspond pas toujours au comportement de bash, dans des cas comme:
        echo test > file divers [bash ignore le mot "divers" et créé le fichier "file" vs "file divers" pour nous]

- parsing: à la fin d'un pipe, verifier que les flags ' et " soient desactivés --> si les quote n'est pas fermé, c'est du MULTILINE -> pas à gérer donc on fait comme on veut

- Dans parsing.c, fonction ft_parse(), une erreur doit retourner FAILURE et non EXIT_FAILURE ?