A COMMENCER

- Creer une fonction display_prompt() ?
- Variable $? et retour des fonctions --> faire du retour des focntions une variable globale ? ou le mettre dans la struct t_cmd
- Exit status de minishell (Bash itself returns the exit status of the last command executed, unless a syntax error occurs, in which case it exits with a non-zero value)
- Valeur de retour des built ins

BUILT INS

- built in export: gerer le +=
- built in cd: reste la recherche dans CDVAR & gérer ou non le cas "invalid option" ?
- built in echo: gerer ou non l'éventualité d'un problème de "write"

AUTRE

- exit status dans le cas d'un mauvais input (dans m_redirs)
- problème: quand on appelle un executable qui est dans le current folder, si on fait cmd: ./nom_executable c'est sensé marcher mais si on fait cmd: nom_executable c'est pas sensé marcher. or nous ca marche aussi dans le 2em cas
    -> lié à cmdpath ?
- pid globale: voir s'il faut un tableau/liste de pid
- ctrl c marche sur une commande du pipe, autre que la dernière ? -> a priori le cas ne risque pas de se présenter
- utiliser le char **env argument du main plutot que __environ pour récupérer l'environnement ? 
- redirs: sur les execed cmds, voir s'il faut "restaurer stdout / stdin" -> a priori on en a plus besoin, car si l'execve retourne une erreur: dans ce cas on affiche le message d'erreur sur STDERR
- dans le cas d'un pipe, est ce qu'il faut 'wait' autres les forked process (car sinon deviennent "zombie" et consomment des ressources) ?
- gérer les "variable assigmenent" ? ex: foo=bar

NORME

- proteger les mallocs, pipe, fork, dup ... -> voir quand ca vaut le coup :)
- read du buffer: pour l'instant limité à 1000 char -> voir si meilleur methode --> utiliser gnl ? Une boucle sur read ? ==> gnl retenu
- changer les headers "grim" ?
- pid globale = OK norme ?
- norminette partout
- mettre des "static"

PARSING

- Gérer les erreurs de synthaxe ?

- $ENV:
    gérer les cas "non basiques" de substitution ?
    -- forme basique: $VAR
    -- forme $!VAR  (parameter indirection)
    -- forme ${VAR}  (pour bien séparer la VAR de ce qu'il y a derrière)
    -- formes du type ${VAR:word}

- > FILE:
    pour l'instant, après > ou >>, le parser lit tout ce qu'il trouve jusqu'à '/0' ou ';' ou '|', et le stock dans le filename (en elevant les espaces au début et à la fin si necessaire)
    ---> ne correspond pas toujours au comportement de bash, dans des cas comme:
        echo test > file divers [bash ignore le mot "divers" et créé le fichier "file" vs "file divers" pour nous]

- parsing: à la fin d'un pipe, verifier que les flags ' et " soient desactivés --> si les quote n'est pas fermé, c'est du MULTILINE -> pas à gérer donc on fait comme on veut
