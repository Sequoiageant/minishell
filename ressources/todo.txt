A COMMENCER

- Creer une fonction display_prompt() ?
- gérer les built ins au sein des pipe

BUILT INS

- built in cd: 
    recherche dans CDVAR & 
    gérer ou non le cas "invalid option" (exit code = 2) ?
- built in echo: gerer ou non l'éventualité d'un problème de "write"
- voir si on ajoute une condition pour les built ins qui exit avec 2

AUTRE

- pid globale: voir s'il faut un tableau/liste de pid
- ctrl c marche sur une commande du pipe, autre que la dernière ? -> a priori le cas ne risque pas de se présenter
- utiliser le char **env argument du main plutot que __environ pour récupérer l'environnement ? 
- redirs: sur les execed cmds, voir s'il faut "restaurer stdout / stdin" -> a priori on en a plus besoin, car si l'execve retourne une erreur: dans ce cas on affiche le message d'erreur sur STDERR
- dans le cas d'un pipe, est ce qu'il faut 'wait' autres les forked process (car sinon deviennent "zombie" et consomment des ressources) ?

BONUS (?)

- gérer les "variable assigmenent" ? ex: foo=bar
- $ENV:
    gérer les cas "non basiques" de substitution ?
    -- forme basique: $VAR
    -- forme $!VAR  (parameter indirection)
    -- forme ${VAR}  (pour bien séparer la VAR de ce qu'il y a derrière)
    -- formes du type ${VAR:word}
- built in export: gerer le += = BONUS

NORME

- proteger les mallocs, pipe, fork, dup ... -> voir quand ca vaut le coup :)
- read du buffer: pour l'instant limité à 1000 char -> voir si meilleur methode --> utiliser gnl ? Une boucle sur read ? ==> gnl retenu
- changer les headers "grim" ?
- pid globale = OK norme ?
- norminette partout
- mettre des "static"

PARSING

- Gérer les erreurs de synthaxe (?)
    -> pas de commande vide avant / après un pipe

- Problèmes avec le PARSING: les redirs sont gérés après, donc problème notamment quand:
    - redir entre guillemet: devrait être ignoré
    - si plusieurs mots après la redir (ex: echo > abc def), seul le premier doit être pris en compte pour le nom du fichier. Sauf si guillemets

- gérer les commandes avec plusieurs redirs

- gerer les situations ou l'espace est echappé:
    ex: echo bonjour > test\ 1 --> normalemnt l'espace arrête le nom du fichier, qui s'appelerait "test". Avec le '\' le fichier s'appelle "test 1"

- > FILE:
    pour l'instant, après > ou >>, le parser lit tout ce qu'il trouve jusqu'à '/0' ou ';' ou '|', et le stock dans le filename (en elevant les espaces au début et à la fin si necessaire)
    ---> ne correspond pas toujours au comportement de bash, dans des cas comme:
        echo test > file divers [bash ignore le mot "divers" et créé le fichier "file" vs "file divers" pour nous]

- parsing: à la fin d'un pipe, verifier que les flags ' et " soient desactivés --> si les quote n'est pas fermé, c'est du MULTILINE -> pas à gérer donc on fait comme on veut

- Dans parsing.c, fonction ft_parse(), une erreur doit retourner FAILURE et non EXIT_FAILURE ?