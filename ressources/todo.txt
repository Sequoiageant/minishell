A COMMENCER

- Creer une fonction d'exit
 ---> cas de "sortie" où il faut gérer les clean: 
        exit() : ok cleans gérés 
        signals: cleans ok ?
        autres cas ? cf dans m_redirs et dans m_executalbe_cmd ou utilisation de la fonction "exit"
- Creer une fonction display_prompt() ?
- Variable $? et retour des fonctions --> faire du retour des focntions une variable globale ? ou le mettre dans la struct t_cmd
- Coder les built ins:
    - pwd
    - export
    - unset
    - env
    - exit --> on fait un del cmd_list et non un del_pipe = voir s'il ne faut pas le faire "plus haut" dans m_traitement pour pouvoir faire un del pipe

CODE

- pid globale: voir s'il faut un tableau/liste de pid
- finir les built ins:
    - cd: reste la recherche dans CDVAR -> a tester JN
    - echo: OK terminé -> à tester JN
- utiliser le char **env argument du main plutot que __environ pour récupérer l'environnement ? 
- pourquoi valgrind donne un "still reachable" lié au get next line ? --> fixed
- redirs: sur les execed cmds, voir s'il faut "restaurer stdout / stdin" -> a priori on en a plus besoin, car si l'execve retourne une erreur: dans ce cas on affiche le message d'erreur sur STDERR

NORME

- proteger les mallocs, pipe, fork, dup ... -> voir quand ca vaut le coup :)
- read du buffer: pour l'instant limité à 1000 char -> voir si meilleur methode --> utiliser gnl ? Une boucle sur read ? ==> gnl retenu
- changer les headers "grim" ?
- pid globale = OK norme ?
- norminette partout
- mettre des "static"

PARSING

- $ENV:
    gérer les cas "non basiques" de substitution ?
    -- forme basique: $VAR
    -- forme $!VAR  (parameter indirection)
    -- forme ${VAR}  (pour bien séparer la VAR de ce qu'il y a derrière)
    -- formes du type ${VAR:word}

- > FILE:
    pour l'instant, après > ou >>, le parser lit tout ce qu'il trouve jusqu'à '/0' ou ';' ou '|', et le stock dans le filename (en elevant les espaces au début et à la fin si necessaire)
    ---> ne correspond pas toujours au comportement de bash, dans des cas comme:
        echo test > file divers [bash ignore le mot "divers" et créé le fichier "file" vs "file divers" pour nous]

- parsing: à la fin d'un pipe, verifier que les flags ' et " soient desactivés --> si les quote n'est pas fermé, c'est du MULTILINE -> pas à gérer donc on fait comme on veut
