A COMMENCER

- Creer une fonction display_prompt() ?

BUILT INS

- built in cd: 
    recherche dans CDVAR & 
    gérer ou non le cas "invalid option" (exit code = 2) ?
- built in echo: gerer ou non l'éventualité d'un problème de "write"
- voir si on ajoute une condition pour les built ins qui exit avec 2

AUTRE

- pid globale: voir s'il faut un tableau/liste de pid
- ctrl c marche sur une commande du pipe, autre que la dernière ? -> a priori le cas ne risque pas de se présenter
- utiliser le char **env argument du main plutot que __environ pour récupérer l'environnement ? 
- redirs: sur les execed cmds, voir s'il faut "restaurer stdout / stdin" -> a priori on en a plus besoin, car si l'execve retourne une erreur: dans ce cas on affiche le message d'erreur sur STDERR

BONUS (?)

- gérer les "variable assigmenent" ? ex: foo=bar
- $ENV:
    gérer les cas "non basiques" de substitution ?
    -- forme basique: $VAR
    -- forme $!VAR  (parameter indirection)
    -- forme ${VAR}  (pour bien séparer la VAR de ce qu'il y a derrière)
    -- formes du type ${VAR:word}
- built in export: gerer le +=

NORME

- proteger les mallocs, pipe, fork, dup ... -> voir quand ca vaut le coup :)
- changer les headers "grim" ?
- pid globale = OK norme ?
- norminette partout
- mettre des "static"

PARSING

- renvoyer une erreur de synthaxe quand il n'y a "rien" derrière le redir

- Gérer les erreurs de synthaxe (?)
    -> pas de commande vide avant / après un pipe

- parsing: à la fin d'un pipe, verifier que les flags ' et " soient desactivés --> si les quote n'est pas fermé, c'est du MULTILINE -> pas à gérer donc on fait comme on veut

- Dans parsing.c, fonction ft_parse(), une erreur doit retourner FAILURE et non EXIT_FAILURE ? OK corrigé