A COMMENCER

- Creer une fonction d'exit
- Creer une fonction display_prompt() ?
- Variable $? et retour des fonctions --> faire du retour des focntions une variable globale ?
- Coder les built ins:
    - pwd
    - export
    - unset
    - env
    - exit --> fonctionne mal après avoir executé un pipe

CODE

- pid globale: voir s'il faut un tableau/liste de pid
- finir les built ins:
    - cd
    - echo
- utiliser le char **env argument du main plutot que __environ pour récupérer l'environnement ? 
- pourquoi valgrind donne un "still reachable" lié au get next line ? --> fixed

NORME

- proteger les mallocs
- proteger les pipe et les fork
- read du buffer: pour l'instant limité à 1000 char -> voir si meilleur methode --> utiliser gnl ? Une boucle sur read ? ==> gnl retenu
- changer les headers "grim" ?
- pid globale = OK norme ?


PARSING

- $ENV:
    gérer les cas "non basiques" de substitution ?
    -- forme basique: $VAR
    -- forme $!VAR  (parameter indirection)
    -- forme ${VAR}  (pour bien séparer la VAR de ce qu'il y a derrière)
    -- formes du type ${VAR:word}

- > FILE:
    pour l'instant, après > ou >>, le parser lit tout ce qu'il trouve jusqu'à '/0' ou ';' ou '|', et le stock dans le filename (en elevant les espaces au début et à la fin si necessaire)
    ---> ne correspond pas toujours au comportement de bash, dans des cas comme:
        echo test > file divers [bash ignore le mot "divers" et créé le fichier "file" vs "file divers" pour nous]

- parsing: à la fin d'un pipe, verifier que les flags ' et " soient desactivés --> si les quote n'est pas fermé, c'est du MULTILINE -> pas à gérer donc on fait comme on veut
