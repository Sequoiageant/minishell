Google doc man bash:
https://docs.google.com/document/d/1Md5AhIjY-1H6xenDQ8D-qWu5CGWgze6Q3J14B6_FQu0/edit?usp=sharing

PLAN

    main()

        initialisation du shell
            message d'accueil si besoin
            recuperer l'environnement
        boucle while(1)
            afficher prompt
            lire buf
            fonction "handle"(buf)

    handle(buf)

        parsing(buf) --> cf paragraphe dédié
            allouer autant de struct s_cmd que necessaire
        traitement(cmd)

    traitement(cmd)

        // trois cas:
        // cas 0: la commande est vide (ou une suite d'espace) -> RAS, on revient au prompt
        // cas 1: la commande appelée est une commande built-in -> executée directement dans notre programme
        // cas 2: pas un built-in: on veut créer un nouveau process pour l'executer, via fork
        // --> avant de faire le fork, on vérifie que la fonction n'est pas un shell built-in
        if empty
            return
        if (ft_check_built_in)
            ft_exec_built
        else
            ft_fork

    A insérer: 
    - les "signaux" (CTRL + C et CTRL + D)
    - le retour des fonctions
    - set la variable $?
    - les pipe / dup / open à faire en fonction des redirections (au début et à la fin)



PARSING

    SUBSTITUTION
    to do: detecter les caracteres et faire la substitution directement
        $               changer en la variable d'env correspondate
    
    QUOTING
    to do: able/disable special treatment of characters
        \               preserves the litteral value of the character that follows
                        ex: echo $PWD donne /home/basile
                            echo \$PWD donne $PWD
                        with the exception of <newline>. If a \<newline> pair appears, and the backslash is not itself quoted, the \<newline> is treated as a line continuation (that is, it is removed from the input stream and effectively ignored).
                        ex: echo basile\
                            brunet
                            donne basilebruent

        ''              preserves the litteral value of each character
                        -> pas de subsitution après $
                        -> le backslash ne preserve pas la litteral value of the character that follows
                        RQ: a single quote may not occur between single quotes, even when preceded by a backslash.

        ''              preserves the litteral value of each character EXCEPT \ and $, that retain their special meaning
                        -> subsitution après $
                        -> the backslash retains its special meaning ONLY when followed by one of the following characters: $, `, ", \, or <newline>. 
                        RQ: a double quote may be quoted within double quotes by preceding it with a backslash.
                        
                            ex sur l'utilisation du backslash avec "" vs '':
                            echo 'basile \$' donne basile \$
                            echo "basile \$' donne basile $

    MULTI COMMANDES
    to do: alloc plusieurs cmd
        ;               multi commandes

    REDIRECTION
    to do: detecter les caracteres et set des flags de redirection
    flags de redirection  = infos necessaires pour lancer les syscall "pipe" et/ou "dup"
        >               OUTPUT = file
                            -> il faut ouvrir le fichier (open classique) et faire le putstr dedans
                            -> besoin du nom du fichier
        >>              OUTPUT = file
                            -> il faut ouvrir le fichier (open avec flag O_APPEND) et faire le putstr dedans
                            -> besoin du nom du fichier
        <               INPUT = file on STDIN: 
                            -> juste a faire un dup du fd du fichier comme dans dup_test.c
                            -> besoin juste du nom du fichier (char *)
        cmd1 | cmd2    STDOUT of cmd1 is STDIN of cmd 2
                            -> pipe to connect both commands, and duplicate (dup) output fd in cmd1 to stdout and inputdf in cmd2 to stdin
                            -> besoin de savoir si on est dans le cas [ cmd | ] ou dans le cas [ | cmd ] 
    cf. sur les pipes et dup: https://tldp.org/LDP/lpg/node10.html#SECTION00721000000000000000
    cf. dup_test.c et pipe_test.c

Special characters:

\a
alert (bell)
\b
backspace
\e
\E
an escape character
\f
form feed
\n
new line
\r
carriage return
\t
horizontal tab
\v
vertical tab

--> ne sont transformés que entre quotes:
echo 'ba\ts' et echo "ba\ts" donnent ba     s
mais echo ba\ts donne ba\ts