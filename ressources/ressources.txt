Google doc man bash:
https://docs.google.com/document/d/1Md5AhIjY-1H6xenDQ8D-qWu5CGWgze6Q3J14B6_FQu0/edit?usp=sharing

PLAN

    main()

        initialisation du shell
            message d'accueil si besoin
            recuperer l'environnement
        boucle while(1)
            afficher prompt
            lire buf
            fonction "handle"(buf)

    handle(buf)

        parsing(buf) --> cf paragraphe dédié
            allouer autant de struct s_cmd que necessaire
        traitement(cmd)

    traitement(cmd)

        // trois cas:
        // cas 0: la commande est vide (ou une suite d'espace) -> RAS, on revient au prompt
        // cas 1: la commande appelée est une commande built-in -> executée directement dans notre programme
        // cas 2: pas un built-in: on veut créer un nouveau process pour l'executer, via fork
        // --> avant de faire le fork, on vérifie que la fonction n'est pas un shell built-in
        if empty
            return
        if (ft_check_built_in)
            ft_exec_built
        else
            ft_fork

    A insérer: 
    - les "signaux" (CTRL + C et CTRL + D)
    - le retour des fonctions
    - set la variable $?
    - les pipe / dup / open à faire en fonction des redirections (au début et à la fin)



PARSING

    SUBSTITUTION
    to do: detecter les caracteres et faire la substitution directement
        $var            changer en la variable d'env correspondate

    SPECIAL CHARACTERS
    Ne sont pas "lus" en tant que tel, sauf s'ils sont "quoted"
        <>              redirection
        |               piping
        ;               new command
        ' "" \          quoting
        space           ignored
        newline         fin de la commande

    QUOTING
    to do:  disable or not special treatment of special characters
            disable or not parameter expansion (substitution with $)
        
        \               disables special treatment of special character
                        ...with the exception of <newline>: PAS A GERER JE PENSE
                        ......if a \<newline> pair appears, and the backslash is not itself quoted, the \<newline> is treated as a line continuation (that is, it is removed from the input stream and effectively ignored).
                        disables parameter expansion

        ''              disables special treatment of all special characters inside
                        ...y compris du \
                        ....y compris du \<newline>: PAS A GERER CEST SUR
                        disables parameter expansion
                        RQ: a single quote may not occur between single quotes, even when preceded by a backslash.

        ""              disables special treatment of all special characters inside
                        ...sauf le \ lorsqu'il precède $, ", \, [ou <newline> PAS A GERER]
                        parameter expansion is enabled
                        RQ: a double quote may be quoted within double quotes by preceding it with a backslash.
        
        PAS A GERER JE PENSE:
        $'string'       Words of the form $'string' are treated specially. 
                        The word expands to string, with backslash-escaped characters replaced as specified by the ANSI C standard.  
                        Backslash escape sequences, if present, are decoded as follows:
                            \a
                            alert (bell)
                            \b
                            backspace
                            \e
                            \E
                            an escape character
                            \f
                            form feed
                            \n
                            new line
                            \r
                            carriage return
                            \t
                            horizontal tab
                            \v
                            vertical tab
                            \\
                            backslash
                            \'
                            single quote
                            \"
                            double quote
                            \nnn
                            the eight-bit character whose value is the octal value nnn (one to three digits)
                            \xHH
                            the eight-bit character whose value is the hexadecimal value HH (one or two hex digits)
                            \cx
                            a control-x character
                            The expanded result is single-quoted, as if the dollar sign had not been present.


    MULTI COMMANDES
    to do: alloc plusieurs cmd
        ;               multi commandes

    REDIRECTION
    to do: detecter les caracteres et set des flags de redirection
    flags de redirection  = infos necessaires pour lancer les syscall "pipe" et/ou "dup"
        >               OUTPUT = file
                            -> il faut ouvrir le fichier (open classique) et faire le putstr dedans
                            -> besoin du nom du fichier
        >>              OUTPUT = file
                            -> il faut ouvrir le fichier (open avec flag O_APPEND) et faire le putstr dedans
                            -> besoin du nom du fichier
        <               INPUT = file on STDIN: 
                            -> juste a faire un dup du fd du fichier comme dans dup_test.c
                            -> besoin juste du nom du fichier (char *)
        cmd1 | cmd2    STDOUT of cmd1 is STDIN of cmd 2
                            -> pipe to connect both commands, and duplicate (dup) output fd in cmd1 to stdout and inputdf in cmd2 to stdin
                            -> besoin de savoir si on est dans le cas [ cmd | ] ou dans le cas [ | cmd ] 
    cf. sur les pipes et dup: https://tldp.org/LDP/lpg/node10.html#SECTION00721000000000000000
    cf. dup_test.c et pipe_test.c

Special characters:

\a
alert (bell)
\b
backspace
\e
\E
an escape character
\f
form feed
\n
new line
\r
carriage return
\t
horizontal tab
\v
vertical tab

--> ne sont transformés que entre quotes:
echo 'ba\ts' et echo "ba\ts" donnent ba     s
mais echo ba\ts donne ba\ts